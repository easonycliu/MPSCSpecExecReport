# Test experiment on new machine
* Memory limit: 1024M
* mem limit low = 512M, mem limit high = 768M, mem limit max = 1024M
* Vector size: 128

## Result on old machine
* Osprey window size 2048, batch size 8192
| Workload  | Osprey |   MAGE |    OS |   Unbounded |
|:----------|-------:|-------:|------:|------------:|
| mvmul     |  12.5s |  22.3s | 26.9s |        7.8s |

## Result on new machine
* Osprey window size 2048, batch size 8192
| Workload  | Osprey |   MAGE |    OS |   Unbounded |
|:----------|-------:|-------:|------:|------------:|
| mvmul     |  17.7s |   9.9s | 38.5s |        3.2s |

* Osprey window size 2048, batch size 65536
| Workload  | Osprey |   MAGE |    OS |   Unbounded |
|:----------|-------:|-------:|------:|------------:|
| mvmul     |  10.4s |   9.9s | 38.5s |        3.2s |

# Test newer settings
## Setting
* Memory limit: 16G
* Osprey param: window size 32768, batch size 131072
* mem limit low = 12G, mem limit high = 14G, mem limit max = 16G
* Vector size: 512

## Results
* Thread num: 1
| Workload  | Osprey  |   MAGE |    OS |   Unbounded |
|:----------|--------:|-------:|------:|------------:|
| mvmul     |  127.3s | 160.8s |   -   |       48.1s |

* Thread num: 4
| Workload  | Osprey  |   MAGE |     OS |   Unbounded |
|:----------|--------:|-------:|-------:|------------:|
| mvmul     |   46.7s |   -    | 188.3s |       13.1s |

# Use MPK to do mprotect as sync page
## History of sync page
* Manually unmap a page so that the page will trigger page fault, which can be used as a syncronization signal of running application and memory programmer
	* Limitation: When a page is frequently used, the unmap operation fails sometimes
* Set `mprotect(PROT_NONE)` to the page so that the page will triger page fault
	* Limitation: In multithread setting, one thread set a page with `mprotect(PROT_NONE)` may be accessed by another thread and trigger a syncronization at wrong time and wrong place
* New design: `pkey_mprotect(PROT_READ | PROT_WRITE, pkey)` + `wrpkru`
	* Each threads are assigned to a unique pkey and `wrpkru` only limit access to the memory that are tagged with the thread's specified pkey
	* `pkru` is a per-thread register so even one thread access the page that are tagged by another thread, it won't trigger syncronization

## Setting
* Memory limit: 16G
* Osprey param: window size 32768, batch size 131072
* mem limit low = 12G, mem limit high = 14G, mem limit max = 16G
* Vector size: 512

## Results
* Thread num: 1
| Workload  | Osprey  |   MAGE |    OS |   Unbounded |
|:----------|--------:|-------:|------:|------------:|
| mvmul     |  133.1s | 160.8s |   -   |       48.1s |

* Thread num: 4
| Workload  | Osprey  |   MAGE |     OS |   Unbounded |
|:----------|--------:|-------:|-------:|------------:|
| mvmul     |   50.1s |   -    | 188.3s |       13.1s |


# TODO
* Apply MPK related optimization
	* No need to iterate to thread private pages and select as syncronization page
* Handle page faults with multiple threads
